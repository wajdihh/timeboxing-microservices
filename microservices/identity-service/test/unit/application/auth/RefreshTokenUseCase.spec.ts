import { RefreshTokenUseCase } from '@identity/application/auth/RefreshTokenUseCase';
import { TokenRepository } from '@identity/domain/auth/TokenRepository';
import { UserRepository } from '@identity/domain/user/UserRepository';
import { UserEntity } from '@identity/domain/user/UserEntity';
import { MetricsPort } from '@identity/application/observability/MetricsPort';
import { InvalidRefreshTokenError } from '@identity/domain/auth/errors/InvalidRefreshTokenError';
import { InvalidSessionError } from '@identity/domain/auth/errors/InvalidSessionError';
import { ID, ResultValue, BaseInfraError } from '@timeboxing/shared';

// Mock ID.generate()
const mockGeneratedId = ID.fake();
jest.mock('@timeboxing/shared', () => {
  const originalModule = jest.requireActual('@timeboxing/shared');
  return {
    ...originalModule,
    ID: {
      ...originalModule.ID,
      generate: jest.fn(() => mockGeneratedId),
      fake: originalModule.ID.fake, // ensure fake is still available if needed elsewhere
      from: originalModule.ID.from, // ensure from is still available
    },
  };
});

describe('RefreshTokenUseCase', () => {
  let useCase: RefreshTokenUseCase;
  let mockUserRepo: jest.Mocked<UserRepository>;
  let mockTokenRepo: jest.Mocked<TokenRepository>;
  let mockMetricsPort: jest.Mocked<MetricsPort>;

  beforeEach(() => {
    mockUserRepo = {
      findByEmail: jest.fn(),
      findByID: jest.fn(),
      save: jest.fn(),
    } as unknown as jest.Mocked<UserRepository>;

    mockTokenRepo = {
      verifyRefreshToken: jest.fn(),
      revokeRefreshToken: jest.fn(),
      generateAuthTokens: jest.fn(),
      verifyAccessToken: jest.fn(),
      decodeAccessToken: jest.fn(),
    } as unknown as jest.Mocked<TokenRepository>;

    mockMetricsPort = {
        incrementRegistration: jest.fn(),
        incrementLogin: jest.fn(),
        incrementLogout: jest.fn(),
        incrementRefreshToken: jest.fn(),
        getMetrics: jest.fn(),
        startRequestTimer: jest.fn().mockReturnValue(jest.fn()),
        incrementRequestCounter: jest.fn(),
        incrementErrorCounter: jest.fn(),
    } as jest.Mocked<MetricsPort>;

    useCase = new RefreshTokenUseCase(mockUserRepo, mockTokenRepo, mockMetricsPort);
  });

  it('should return user entity for a valid refresh token and existing user', async () => {
    // Given
    const refreshToken = 'valid-refresh-token';
    const userEntityCreateResult = UserEntity.create('Test User', 'test@example.com', 'hashedPassword');
    const user = userEntityCreateResult.unwrap(); // ID is generated by UserEntity.create
    const expectedUserId = user.id; // This ID was generated by the mocked ID.generate

    mockTokenRepo.verifyRefreshToken.mockResolvedValue(
      ResultValue.ok({ userId: expectedUserId, sessionID: 'session-id' }), // Correct payload
    );
    mockUserRepo.findByID.mockResolvedValue(ResultValue.ok(user)); // Correct return type

    // When
    const result = await useCase.execute(refreshToken);

    // Then
    expect(result.isOk).toBe(true);
    const unwrappedUser = result.unwrap();
    expect(unwrappedUser).toBeInstanceOf(UserEntity);
    expect(unwrappedUser?.id.equals(expectedUserId)).toBe(true);
    expect(mockTokenRepo.verifyRefreshToken).toHaveBeenCalledWith(refreshToken);
    expect(mockUserRepo.findByID).toHaveBeenCalledWith(expectedUserId);
    expect(mockMetricsPort.incrementRefreshToken).toHaveBeenCalled();
  });

  it('should return error if token verification fails', async () => {
    // Given
    const refreshToken = 'invalid-refresh-token';
    const verificationError = new InvalidRefreshTokenError(); // Removed argument
    mockTokenRepo.verifyRefreshToken.mockResolvedValue(ResultValue.error(verificationError));

    // When
    const result = await useCase.execute(refreshToken);

    // Then
    expect(result.isOk).toBe(false);
    expect(result.error).toBe(verificationError);
    expect(mockUserRepo.findByID).not.toHaveBeenCalled();
  });

  it('should return InvalidRefreshTokenError if userRepository.findByID fails', async () => {
    // Given
    const refreshToken = 'valid-refresh-token';
    const userId = ID.fake(); // Use a different ID for this specific mock
     mockTokenRepo.verifyRefreshToken.mockResolvedValue(
      ResultValue.ok({ userId, sessionID: 'session-id' }),
    );
    // Simulate a failure in the repository layer for findByID
    const repoError = new BaseInfraError('Database error');
    mockUserRepo.findByID.mockResolvedValue(ResultValue.error(repoError));

    // When
    const result = await useCase.execute(refreshToken);

    // Then
    expect(result.isOk).toBe(false);
    expect(result.error).toBeInstanceOf(InvalidRefreshTokenError); // As per use case logic
    expect(mockUserRepo.findByID).toHaveBeenCalledWith(userId);
  });

  it('should return InvalidRefreshTokenError if user is not found by ID', async () => {
    // Given
    const refreshToken = 'valid-refresh-token';
    const userId = ID.fake(); // Use a different ID for this specific mock
    mockTokenRepo.verifyRefreshToken.mockResolvedValue(
      ResultValue.ok({ userId, sessionID: 'session-id' }),
    );
    mockUserRepo.findByID.mockResolvedValue(ResultValue.ok(null)); // User not found

    // When
    const result = await useCase.execute(refreshToken);

    // Then
    expect(result.isOk).toBe(false);
    expect(result.error).toBeInstanceOf(InvalidRefreshTokenError);
    expect(mockUserRepo.findByID).toHaveBeenCalledWith(userId);
  });

  it('should return InvalidSessionError if token verification returns InvalidSessionError', async () => {
    // Given
    const refreshToken = 'invalid-session-token';
    const sessionError = new InvalidSessionError();
    mockTokenRepo.verifyRefreshToken.mockResolvedValue(ResultValue.error(sessionError));

    // When
    const result = await useCase.execute(refreshToken);

    // Then
    expect(result.isOk).toBe(false);
    expect(result.error).toBe(sessionError);
    expect(result.error).toBeInstanceOf(InvalidSessionError);
    expect(mockUserRepo.findByID).not.toHaveBeenCalled();
  });
});
